## Docker, Kubernetes and Cloud Native

True portability comes from using industry standard [Docker containers](https://www.docker.com/resources/what-container) for packaging and deploying our workloads (web apps, microservices, legacy apps etc). They can be deployed to any orchestrator (Kubernetes, DC/OS, Mesos, Docker Swarm), but 2 years ago [Kubernetes](https://kubernetes.io/docs/concepts/overview/what-is-kubernetes/) won the battle and is now used almost universally at organisations across the world. All the major cloud providers have managed Kubernetes offerings ([AWS EKS](https://aws.amazon.com/eks/), [GCP GKE](https://cloud.google.com/kubernetes-engine/) and [Azure AKS](https://azure.microsoft.com/en-us/services/kubernetes-service/)), which are free to use (you only pay for the VMs that form the nodes in the cluster).

All the cloud providers also have serverless offerings ([AWS Lambda](https://aws.amazon.com/lambda/), [GCP Cloud Functions](https://aws.amazon.com/lambda/) and [Azure functions](https://azure.microsoft.com/en-us/services/functions/)). This is an even higher level of abstraction where you deploy just functions and pay per second of runtime. Serverless is becoming a viable alternative, but whilst it is cheap for intermittent workloads, it can be expensive for continuous workloads and we want to have our microservices always running. Serverless cold start times are still too long, adversely affecting user experience and possibly making Serverless an unsuitable option for many services.

Inside the Docker containers are [Cloud Native](https://www.cncf.io/) workloads. There is an excellent [article](https://thenewstack.io/10-key-attributes-of-cloud-native-applications/) on the New Stack which describes what it means to be Cloud Native, but basically cloud native services are designed to be lightweight, run in containers, are [12-factor](https://12factor.net/), and can be built, managed and deployed using [DevOps](https://en.wikipedia.org/wiki/DevOps) practices.
